

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Chapter 7: Leaf-Spine Fabric &mdash; Software-Defined Networks: A Systems Approach Version 0.1-dev documentation</title>
  

  
  
    <link rel="shortcut icon" href="static/bridge.ico"/>
  
  
  

  
  <script type="text/javascript" src="static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="static/documentation_options.js"></script>
        <script type="text/javascript" src="static/jquery.js"></script>
        <script type="text/javascript" src="static/underscore.js"></script>
        <script type="text/javascript" src="static/doctools.js"></script>
        <script type="text/javascript" src="static/language_data.js"></script>
    
    <script type="text/javascript" src="static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="static/css/rtd_theme_mods.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Chapter 8: Future of SDN" href="future.html" />
    <link rel="prev" title="Chapter 6: Network OS" href="onos.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Software-Defined Networks: A Systems Approach
          

          
          </a>

          
            
            
              <div class="version">
                Version 0.1-dev
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="preface.html">Preface</a></li>
<li class="toctree-l1"><a class="reference internal" href="intro.html">Chapter 1:  Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="uses.html">Chapter 2:  Use Cases</a></li>
<li class="toctree-l1"><a class="reference internal" href="arch.html">Chapter 3:  Basic Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="switch.html">Chapter 4:  White-Box Switches</a></li>
<li class="toctree-l1"><a class="reference internal" href="stratum.html">Chapter 5:  Switch OS</a></li>
<li class="toctree-l1"><a class="reference internal" href="onos.html">Chapter 6:  Network OS</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Chapter 7:  Leaf-Spine Fabric</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#feature-set">7.1 Feature Set</a></li>
<li class="toctree-l2"><a class="reference internal" href="#segment-routing">7.2 Segment Routing</a></li>
<li class="toctree-l2"><a class="reference internal" href="#routes-and-multicast-trees">7.3 Routes and Multicast Trees</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="future.html">Chapter 8:  Future of SDN</a></li>
<li class="toctree-l1"><a class="reference internal" href="README.html">About This Book</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Software-Defined Networks: A Systems Approach</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Chapter 7:  Leaf-Spine Fabric</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/trellis.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <div class="rst-breadcrumbs-buttons" role="navigation" aria-label="breadcrumb navigation">
      
        <a href="future.html" class="btn btn-neutral float-right" title="Chapter 8: Future of SDN" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="onos.html" class="btn btn-neutral float-left" title="Chapter 6: Network OS" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
  </div>
  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="chapter-7-leaf-spine-fabric">
<h1>Chapter 7:  Leaf-Spine Fabric<a class="headerlink" href="#chapter-7-leaf-spine-fabric" title="Permalink to this headline">¶</a></h1>
<p>This chapter describes Trellis, a leaf-spine switching fabric
implemented by a collection of control applications running on top of
ONOS. We have introduced various aspects of Trellis in earlier
chapters, but we summarize the highlights here before getting into the
details.</p>
<ul class="simple">
<li>Trellis supports the leaf-spine fabric topology that is commonly
used to interconnect multiple racks of servers in a datacenter (see
<a class="reference internal" href="uses.html#fig-leaf-spine"><span class="std std-numref">Figure 9</span></a>), but it also supports
multi-site deployments (see <a class="reference internal" href="arch.html#fig-trellis"><span class="std std-numref">Figure 13</span></a>).
Trellis uses only white-box switches to build out the fabric. It can
run on a mix of fixed-function and programmable pipelines, but is
running in production with the former.</li>
<li>Trellis supports a wide-range of L2/L3 features, all re-implemented
as SDN control apps (with the exception of Quagga, which is used to
exchange BGP routes with external peers). Trellis implements L2
connectivity within each server rack, and L3 connectivity between
racks.</li>
<li>Trellis supports access/edge networking technologies, such as PON
and RAN, including support for (a) routing IP traffic to/from devices
connected to those access networks, and (b) off-loading access
network functionality into the fabric switches.</li>
</ul>
<p>This chapter does not give a comprehensive description of every
Trellis feature, but it does illustrate some of the thought processes
involved in building a comprehensive and production-grade network
using SDN.</p>
<div class="section" id="feature-set">
<h2>7.1 Feature Set<a class="headerlink" href="#feature-set" title="Permalink to this headline">¶</a></h2>
<p>SDN provides an opportunity to customize the network, but for
pragmatic reasons, the first requirement for adoption is to reproduce
functionality that already exists, and do so in a way that reproduces
the resilience and scalability of legacy solutions. Trellis has
satisfied this requirement, which we summarize here.</p>
<p>First, with respect to L2 connectivity, Trellis supports VLANs,
including native support for forwarding traffic based on just an outer
VLAN id, as well as QinQ support based on an outer/inner VLAN id
pair. Support for QinQ is particularly relevant to access networks,
where double tagging is used to isolate traffic belonging to different
service classes. In addition, Trellis supports L2 tunnels across the
L3 fabric (both single and double tagged).</p>
<p>Second, with respect to L3 connectivity, Trellis supports IPv4 and
IPv6 routing for both unicast and multicast addresses. For the latter,
Trellis implements centralized multicast tree construction (as opposed
to running a protocol like PIM), but does include IGMP support for end
hosts wishing to join/leave multicast groups. Trellis also supports
both ARP (for IPv4 address translation) and NDP (for IPv6 neighbor
discovery), along with support for both DHCPv4 and DHCPv6.</p>
<p>Third, Trellis provides high availability in the face of link or
switch failures. It does this through a combination of well-known
techniques: dual-homing, link binding, and ECMP link groups. As
illustrated in <a class="reference internal" href="#fig-netconfig"><span class="std std-numref">Figure 33</span></a>, each server in a
Trellis cluster is connected to a pair of ToR (leaf) switches, where
the OS running on each compute server implements active-active link
bonding. Each leaf switch is then connected by a pair of links to a
pair of spine switches, with an ECMP group defined for the pair of
links connecting each leaf to a given spine and for the set of links
connecting each leaf to a pair of spines. The cluster as a whole then
has multiple connections to external routes, shown via leaf switches 3
and 4 in the Figure. Not shown in <a class="reference internal" href="#fig-netconfig"><span class="std std-numref">Figure 33</span></a>
is the fact that Trellis runs on top of ONOS, which is itself
replicated for the sake of availability. In a configuration like the
one shown here, ONOS (and hence the Trellis control applications) are
replicated on three to five servers.</p>
<div class="figure align-center" id="id1">
<span id="fig-netconfig"></span><a class="reference internal image-reference" href="_images/Slide31.png"><img alt="_images/Slide31.png" src="_images/Slide31.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-number">Figure 33. </span><span class="caption-text">High availability through a combination of dual-homing, link
bonding, and ECMP groups.</span></p>
</div>
<p>Details about link aggregation and ECMP are beyond the scope of this
book, but the idea is straightforward: the packet forwarding mechanism
is augmented to load balance outgoing packets among a group (e.g., a
pair) of links (egress ports) rather than having just a single “best”
output link (egress port). This both improves bandwidth and results in
an automatic recover mechanism should any single link fail.</p>
<p>Fourth, with respect to scalability, Trellis has demonstrated the
ability to support up to 120k routes and 250k flows. This is in a
configuration that includes two spine switches and eight leaf
switches, the latter implying up to four racks of servers. As with
availability, Trellis’s ability to scale performance is directly due
to ONOS’s ability to scale.</p>
</div>
<div class="section" id="segment-routing">
<h2>7.2 Segment Routing<a class="headerlink" href="#segment-routing" title="Permalink to this headline">¶</a></h2>
<p>The previous section focused on <em>what</em> Trellis does. This section
focuses on <em>how</em>, where the core strategy is based on <em>Segment Routing
(SR)</em>. The term “segment routing” comes from the idea that the
end-to-end path between any pair of hosts can be defined by a sequence
of segments, where label-switching is used to traverse a sequence of
segments along an end-to-end path. The idea is an application of
<em>Multi-Protocol Label Switching (MPLS)</em>, which you can read more about
here:</p>
<div class="admonition-further-reading admonition" id="reading-mpls">
<p class="first admonition-title">Further Reading</p>
<p class="last"><a class="reference external" href="https://book.systemsapproach.org/scaling/mpls.html">Multi-Protocol Label Switching</a>. <em>Computer
Networks: A Systems Approach</em>, 2020.</p>
</div>
<p>When applied to a leaf-spine fabric, there are always two segments
involved—leaf-to-spine and spine-to-leaf—where Tellis programs the
switches to match and then push/pop MPLS labels.  <a class="reference internal" href="#fig-sr"><span class="std std-numref">Figure 34</span></a> illustrates how SR works in Trellis using a simple
configuration that forwards traffic between a pair of hosts: 10.0.1.1
and 10.0.2.1. In this example, the servers connected to Leaf 1 are on
subnet 10.0.1/24, the servers connected to Leaf 2 are on subnet
10.0.2/24, and each of the switches have an assigned MPLS id: 101,
103, 102, and 104.</p>
<div class="figure align-center" id="id2">
<span id="fig-sr"></span><a class="reference internal image-reference" href="_images/Slide32.png"><img alt="_images/Slide32.png" src="_images/Slide32.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-number">Figure 34. </span><span class="caption-text">Example of Segment Routing being used to forward traffic between a
pair of hosts.</span></p>
</div>
<p>When Host 1 sends a packet with destination address 10.0.2.1 it is by
default forwarded to the server’s ToR/leaf switch. (Because of link
aggregation the packet could show up at either ToR, but the behavior
is exactly the same for both.) Leaf 1 matches the destination IP
address, learns this packet needs to cross the fabric and emerge at
Leaf 2 to reach subnet 10.0.2/24, and so pushes the MPLS label 102
onto the packet. Because of ECMP, Leaf 1 can forward the resulting
packet to either spine, at which point that switch matches the MPLS
label 102, pops the label off the header, and forwards it to Leaf 2.
Finally, Leaf 2 matches the destination IP address and forwards the
packet along to Host 2.</p>
<p>What you should take away from this example is that SR is highly
stylized. For a given combination of leaf and spine switches, Trellis
pre-computes the possible paths and installs the corresponding
match/action rules in the underlying switches. The complexity having
to do with balancing load across multiple paths is delegated to ECMP,
which is similarly unaware of any end-to-end paths. From an
implementation perspective, the Trellis control application that
implements SR passes these match/action rules to ONOS, which in turn
installs them on the underlying switches. Trellis also maintains its
own Atomix map to manage the set of ECMP groups connecting leaf and
spine switches.</p>
</div>
<div class="section" id="routes-and-multicast-trees">
<h2>7.3 Routes and Multicast Trees<a class="headerlink" href="#routes-and-multicast-trees" title="Permalink to this headline">¶</a></h2>
<p>On top of Segment Routing, which establies data paths between leaf
switches, Trellis also takes advantage of the Route and Mcast services
introduced in Chapter 6 to determine which switches serve each IP
prefix, and where to find all the hosts connected to each multicast
group, respectively.</p>
<p>Trellis does not run distributed protocols like BGP or OSPF to learn
about routes, or IGMP or PIM to manage multicast trees.  Instead, it
computes the right answers based on global information, and then
pushes these mappings to the Route and Mcast services. This is
straightforward to do because Trellis imposes the simplifying
constraint that each rack corresponds to exactly one IP subnet.</p>
<p>To make this discussion more concrete, consider that ONOS Services can
be invoked via a RESTful API, or alternatively, through a CLI that is
a thin wrapper around the RESTful <code class="docutils literal notranslate"><span class="pre">GET</span></code>, <code class="docutils literal notranslate"><span class="pre">POST</span></code> and <code class="docutils literal notranslate"><span class="pre">DELETE</span></code>
calls.  Using the CLI because it is cleaner, one can query the Route
service to learn the existing routes it knows about:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>onos&gt; routes

B: Best route, R: Resolved route

Table: ipv4
B R  Network            Next Hop        Source (Node)
     0.0.0.0/0          172.16.0.1      FPM (127.0.0.1)
&gt; *  1.1.0.0/18         10.0.1.20       STATIC
&gt; *  10.0.99.0/24       10.0.1.1        FPM (127.0.0.1)
  *  10.0.99.0/24       10.0.6.1        FPM (127.0.0.1)
   Total: 2

Table: ipv6
B R  Network                                     Next Hop                                Source (Node)
&gt; *  2000::7700/120                              fe80::288:ff:fe00:1                     FPM (127.0.0.1)
&gt; *  2000::8800/120                              fe80::288:ff:fe00:2                     FPM (127.0.0.1)
&gt; *  2000::9900/120                              fe80::288:ff:fe00:1                     FPM (127.0.0.1)
  *  2000::9900/120                              fe80::288:ff:fe00:2                     FPM (127.0.0.1)
   Total: 3
</pre></div>
</div>
<p>Similarly, one can add a static route to the Route Service:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">onos&gt; route-add &lt;prefix&gt; &lt;nexthop&gt;</span>
<span class="go">onos&gt; route-add 1.1.0.0/18 10.0.1.20</span>
<span class="go">onos&gt; route-add 2020::101/120 2000::1</span>
</pre></div>
</div>
<p>One thing to note about these examples is that there are two possible
sources for routes. One is that the route is <code class="docutils literal notranslate"><span class="pre">STATIC</span></code>, which usually
means that Trellis inserted it, with full knowledge of the what prefix
it has assigned to each rack in the cluster. (Human operators could
also add a <code class="docutils literal notranslate"><span class="pre">STATIC</span></code> route using the CLI, but this would be an
exception rather than the rule.)</p>
<p>The second possibility is that <code class="docutils literal notranslate"><span class="pre">FPM</span></code> was the source. FPM is yet
another ONOS Service (one of the Trellis suite of services), and its
job is to learn routes from external sources, which it does by tapping
into a locally running Quagga process that is configured to peer with
BPG neighbors. Whenever FPM learns about an external route, is adds
the corresponding prefix-to-nexthop mapping to the Route service,
indicating that the destination prefix is reachable via the leaf
switches that connect the fabric to upstream routers (e.g., Switches 3
and 4 in <a class="reference internal" href="#fig-netconfig"><span class="std std-numref">Figure 33</span></a>).</p>
<p>The story with multicast is similar. Again using the ONOS CLI, it is
possible to create a new muticast route and add a sink to it. For example:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">onos&gt; mcast-host-join -sAddr * -gAddr 224.0.0.1 -srcs 00:AA:00:00:00:01/None -srcs 00:AA:00:00:00:05/None -sinks 00:AA:00:00:00:03/None -sinks 00:CC:00:00:00:01/None</span>
</pre></div>
</div>
<p>specifies <em>Any-Source Multicast (ASM)</em>  (<code class="docutils literal notranslate"><span class="pre">sAddr</span> <span class="pre">*</span></code>), a multicast group address
(<code class="docutils literal notranslate"><span class="pre">gAddr</span></code>), the group source addresses (<code class="docutils literal notranslate"><span class="pre">srcs</span></code>) and the group sink
addresses (<code class="docutils literal notranslate"><span class="pre">sinks</span></code>). A sink can then be removed as follows:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">onos&gt; mcast-sink-delete -sAddr * -gAddr 224.0.0.1 -h  00:AA:00:00:00:03/None</span>
</pre></div>
</div>
<p>Again, there is no PIM or IGMP running, but instead, Trellis offers a
programmatic inteface for network operators to define a multicast tree
through a sequence of such calls. For example, when Trellis runs as
part of an access network that delivers IPTV to subscribers, it is the
operator’s channel-management software that issues calls similar to
the one’s shown above (except, of course, using the RESTful API rather
than the CLI). So the next time you use your TV remote to change
channels, it is possible you are triggering calls down the SDN stack
described throughout this book!</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="future.html" class="btn btn-neutral float-right" title="Chapter 8: Future of SDN" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="onos.html" class="btn btn-neutral float-left" title="Chapter 6: Network OS" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>
